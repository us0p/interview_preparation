Quick Sort
In quick sort you swap the elements of the array in place, halving the array
after each step.

for that you'll need:
- pivot: usually the last element of the current view of the array.
- swaps made: starts at the begining of the current view of the array and
  marks number of swaps made.
- current index: starts at the begining of the current view of the array and
  loops over every element of the current view but the pivot.

with these elements in place:
1. for each current index you'll compare its value with the pivot.
2. if the pivot is greater than the current index value, swap it with the value
   at the swaps made position, and increase the swap cout by 1.
3. after looping over every index, swap the pivot with the swaps made position.
4. repeat the proccess by creating two partitions of the array, one for each
   side of the array, those partitions shouldn't include the pivot. You should
   repeat this until the start and end index overlap.

note that after partitioning the array, you'll always have a weak sorted array,
meaning that everything at the left of the pivot is smaller than the pivot and
everything at the right is greater than.

Time Complexity:
- Average Case: ùúÉ(log n).
- Worst Case: O(n¬≤) - This occurs when the pivot selection is consistently poor.
  This occurs when the pivot is the smallest or greatest element. When the
  pivot is always the smallest or greatest of the set, the partitioning step
  will move only one element relative to the remaining elements. thus to sort
  an array of n itens you'll have to perform n partitions, leading to a O(n¬≤)
  time complexity.
